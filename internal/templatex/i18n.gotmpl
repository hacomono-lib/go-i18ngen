// Code generated by i18ngen. DO NOT EDIT.
package {{.PackageName}}

import (
	"bytes"
	"fmt"
	"strings"
	"sync"
	"text/template"
)

// Primary locale for fallback (first locale in configuration)
const primaryLocale = "{{.PrimaryLocale}}"

// Template cache and function map for better performance
var (
	templateCache = make(map[string]*template.Template)
	templateMutex sync.RWMutex
	templateFuncs template.FuncMap
	funcOnce      sync.Once
)

// getTemplateFunctions returns cached template functions for message rendering
func getTemplateFunctions() template.FuncMap {
	funcOnce.Do(func() {
		templateFuncs = template.FuncMap{
			"title": func(s string) string {
				if len(s) == 0 {
					return s
				}
				return strings.ToUpper(s[:1]) + s[1:]
			},
			"upper": func(s string) string {
				return strings.ToUpper(s)
			},
			"lower": func(s string) string {
				return strings.ToLower(s)
			},
			"camelCase": func(s string) string {
				parts := strings.Split(s, "_")
				if len(parts) == 0 {
					return s
				}
				var builder strings.Builder
				builder.Grow(len(s)) // Pre-allocate capacity
				builder.WriteString(parts[0])
				for i := 1; i < len(parts); i++ {
					if len(parts[i]) > 0 {
						builder.WriteString(strings.ToUpper(parts[i][:1]))
						builder.WriteString(parts[i][1:])
					}
				}
				return builder.String()
			},
		}
	})
	return templateFuncs
}

// getOrCreateTemplate gets a cached template or creates and caches a new one
func getOrCreateTemplate(messageID, templateStr string) (*template.Template, error) {
	var builder strings.Builder
	builder.Grow(len(messageID) + len(templateStr) + 1) // Pre-allocate for key
	builder.WriteString(messageID)
	builder.WriteByte(':')
	builder.WriteString(templateStr)
	cacheKey := builder.String()

	// Try to get from cache with read lock
	templateMutex.RLock()
	if t, exists := templateCache[cacheKey]; exists {
		templateMutex.RUnlock()
		return t, nil
	}
	templateMutex.RUnlock()

	// Create template with write lock
	templateMutex.Lock()
	defer templateMutex.Unlock()

	// Double-check pattern
	if t, exists := templateCache[cacheKey]; exists {
		return t, nil
	}

	t, err := template.New(messageID).Funcs(getTemplateFunctions()).Parse(templateStr)
	if err != nil {
		return nil, err
	}

	templateCache[cacheKey] = t
	return t, nil
}

// renderTemplate renders a message template with the given parameters
func renderTemplate(locale, messageID string, tmpl map[string]string, params map[string]string) string {
	templateStr, exists := tmpl[locale]
	if !exists {
		// Fallback to primary locale if locale not found
		templateStr, exists = tmpl[primaryLocale]
		if !exists {
			// Fallback to any available locale
			for _, t := range tmpl {
				templateStr = t
				break
			}
		}
	}

	if templateStr == "" {
		return fmt.Sprintf("[Missing template: %s.%s]", messageID, locale)
	}

	t, err := getOrCreateTemplate(messageID, templateStr)
	if err != nil {
		return fmt.Sprintf("[Template parse error: %s]", err.Error())
	}

	var buf bytes.Buffer
	err = t.Execute(&buf, params)
	if err != nil {
		return fmt.Sprintf("[Template execution error: %s]", err.Error())
	}

	return buf.String()
}

// Message templates
var templates = map[string]map[string]string{
{{- range $msg := .Messages}}
	"{{$msg.ID}}": {
		{{- range $locale := sortLocales $msg.Templates}}
		"{{$locale}}": `{{index $msg.Templates $locale}}`,
		{{- end}}
	},
{{- end}}
}

{{- range $ph := .Placeholders}}
{{- if $ph.HasLocaleFiles}}
// {{$ph.Name}} templates
var {{camelCase $ph.Name}}Templates = map[string]map[string]string{
	{{- range $id := sortMapKeys $ph.LocaleTemplates}}
	"{{$id}}": {
		{{- range $locale := sortLocales (index $ph.LocaleTemplates $id)}}
		"{{$locale}}": "{{index (index $ph.LocaleTemplates $id) $locale}}",
		{{- end}}
	},
	{{- end}}
}
{{- end}}
{{- end}}

// Localizable interface for all i18n types
type Localizable interface {
	Localize(locale string) string
	ID() string
}

{{range .PlaceholderDefs}}
{{- if .IsValue}}
type {{.StructName}} struct {
	Value string
}

// New{{.StructName}} creates a new {{.StructName}} instance
func New{{.StructName}}(value string) {{.StructName}} {
	return {{.StructName}}{Value: value}
}

func (p {{.StructName}}) Localize(locale string) string {
	return p.Value
}

func (p {{.StructName}}) ID() string {
	return "{{(index .Items 0).ID}}"
}
{{- else}}
type {{.StructName}} struct {
	id string
}

// New{{.StructName}} creates a new {{.StructName}} instance
func New{{.StructName}}(id string) {{.StructName}} {
	return {{.StructName}}{id: id}
}

func (p {{.StructName}}) Localize(locale string) string {
	templates, exists := {{.VarName}}[p.id]
	if !exists {
		return fmt.Sprintf("[Missing {{.StructName}} ID: %s]", p.id)
	}

	result, exists := templates[locale]
	if !exists {
		// Fallback to primary locale if locale not found
		result, exists = templates[primaryLocale]
		if !exists {
			// Fallback to any available locale
			for _, t := range templates {
				result = t
				break
			}
		}
	}

	if result == "" {
		return fmt.Sprintf("[Missing {{.StructName}} template: %s.%s]", p.id, locale)
	}

	return result
}

func (p {{.StructName}}) ID() string {
	return p.id
}
{{- end}}

{{- if not .IsValue}}
// {{.StructName}}s provides utility access to {{.StructName}} instances.
//
// This utility struct contains pre-defined instances for common use cases.
// Each field provides access to localized text values.
//
// Available instances:
{{- range $item := .Items}}
//   - {{$item.FieldName}}: "{{$item.ID}}"
{{- end}}
var {{.StructName}}s = struct {
{{- $structName := .StructName}}
{{- range $item := .Items}}
	// {{$item.FieldName}} represents "{{$item.ID}}"
	//
	// Localized values:
	{{- $locales := sortLocales $item.Templates}}
	{{- range $locale := $locales}}
	//   • [{{$locale}}] "{{commentSafe (index $item.Templates $locale)}}"
	{{- end}}
	{{$item.FieldName}} {{$structName}}
{{- end}}
}{
{{- range .Items}}
	{{.FieldName}}: {{$structName}}{id: "{{.ID}}"},
{{- end}}
}
{{- end}}
{{end}}

{{range $msg := .MessageDefs}}
type {{$msg.StructName}} struct {
{{- range $msg.Fields}}
	{{.FieldName}} {{.Type}}
{{- end}}
}

// New{{$msg.StructName}} creates a new {{$msg.StructName}} instance.
//
// Available localized templates:
{{- $locales := sortLocales $msg.Templates}}
{{- range $locale := $locales}}
//   • [{{$locale}}] "{{commentSafe (index $msg.Templates $locale)}}"
{{- end}}
func New{{$msg.StructName}}({{- range $i, $field := $msg.Fields}}{{if $i}}, {{end}}{{camelCase .TemplateKey}} {{.Type}}{{- end}}) {{$msg.StructName}} {
	return {{$msg.StructName}}{
{{- range $msg.Fields}}
		{{.FieldName}}: {{camelCase .TemplateKey}},
{{- end}}
	}
}

func (m {{$msg.StructName}}) Localize(locale string) string {
	return renderTemplate(locale, "{{$msg.ID}}", templates["{{$msg.ID}}"], map[string]string{
{{- range $msg.Fields}}
		"{{.TemplateKey}}": m.{{.FieldName}}.Localize(locale),
{{- end}}
	})
}

func (m {{$msg.StructName}}) ID() string {
	return "{{$msg.ID}}"
}
{{end}}
