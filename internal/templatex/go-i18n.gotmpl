// Code generated by i18ngen. DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	"strings"
	"sync"

	"github.com/nicksnyder/go-i18n/v2/i18n"
	"golang.org/x/text/language"
	"gopkg.in/yaml.v3"
)

// Bundle and localizer management
var (
	bundle     *i18n.Bundle
	localizers = make(map[string]*i18n.Localizer)
	localizerMu sync.RWMutex
)

// Message data embedded in the binary
var messageData = map[string][]byte{
{{- range $locale, $messages := .MessagesByLocale}}
	"{{$locale}}": []byte(`{{range $msgID, $template := $messages}}{{$msgID}}: "{{$template}}"
{{end}}`),
{{- end}}
}

// Placeholder data embedded in the binary
var placeholderData = map[string]map[string]string{
{{- range $ph := .Placeholders}}
{{- if $ph.HasLocaleFiles}}
{{- range $id := sortMapKeys $ph.LocaleTemplates}}
	"{{$id}}": {
		{{- range $locale := sortLocales (index $ph.LocaleTemplates $id)}}
		"{{$locale}}": "{{index (index $ph.LocaleTemplates $id) $locale}}",
		{{- end}}
	},
{{- end}}
{{- end}}
{{- end}}
}

func init() {
	bundle = i18n.NewBundle(language.Make("{{.PrimaryLocale}}"))
	bundle.RegisterUnmarshalFunc("yaml", yaml.Unmarshal)
	
	// Load messages from embedded data
	for locale, data := range messageData {
		bundle.MustParseMessageFileBytes(data, locale+".yaml")
	}
}

// getLocalizer returns a cached localizer for the given locale
func getLocalizer(locale string) *i18n.Localizer {
	localizerMu.RLock()
	if localizer, exists := localizers[locale]; exists {
		localizerMu.RUnlock()
		return localizer
	}
	localizerMu.RUnlock()
	
	localizerMu.Lock()
	defer localizerMu.Unlock()
	
	// Double-check pattern
	if localizer, exists := localizers[locale]; exists {
		return localizer
	}
	
	localizer := i18n.NewLocalizer(bundle, locale)
	localizers[locale] = localizer
	return localizer
}

// localizeMessage renders a message using go-i18n
func localizeMessage(messageID string, templateData map[string]interface{}, locale string) string {
	localizer := getLocalizer(locale)
	
	result, err := localizer.Localize(&i18n.LocalizeConfig{
		MessageID: messageID,
		TemplateData: templateData,
	})
	
	if err != nil {
		// Return error message in a recognizable format
		return fmt.Sprintf("[Localization error for %s.%s: %s]", messageID, locale, err.Error())
	}
	
	return result
}

// localizeWithFields is a helper function for simple field-based localization
func localizeWithFields(messageID, locale string, fields map[string]string) string {
	return localizeMessage(messageID, buildTemplateData(messageID, locale, fields), locale)
}

// localizeWithConfig is a helper function for standard localization with i18n.LocalizeConfig
func localizeWithConfig(messageID, locale string, templateData map[string]interface{}, pluralCount *int, pluralKey string) string {
	config := &i18n.LocalizeConfig{
		MessageID:    messageID,
		TemplateData: templateData,
	}
	
	if pluralCount != nil {
		config.PluralCount = *pluralCount
		// Add the actual plural placeholder key to TemplateData for template access
		if pluralKey != "" {
			templateData[pluralKey] = *pluralCount
			
			// Also add case variations if different from original
			lowercaseKey := strings.ToLower(pluralKey)
			if lowercaseKey != pluralKey {
				templateData[lowercaseKey] = *pluralCount
			}
			
			uppercaseKey := strings.ToUpper(pluralKey)
			if uppercaseKey != pluralKey {
				templateData[uppercaseKey] = *pluralCount
			}
		}
	}
	
	localizer := getLocalizer(locale)
	return localizer.MustLocalize(config)
}

// buildTemplateData constructs template data with template function processing
func buildTemplateData(messageID, locale string, fields map[string]string) map[string]interface{} {
	result := make(map[string]interface{}, len(fields)) // Pre-allocate capacity
	
	for fieldName, value := range fields {
		result[fieldName] = processField(value, messageID, fieldName, locale)
	}
	
	return result
}

// processField applies template functions to a field value
func processField(value, messageID, fieldName, locale string) string {
	if templateFunctions != nil {
		if functions, exists := templateFunctions[messageID]; exists {
			if localeFunctions, exists := functions[locale]; exists {
				if fieldFunctions, exists := localeFunctions[fieldName]; exists {
					return applyTemplateFunctions(value, fieldFunctions)
				}
			}
		}
	}
	return value
}

// applyTemplateFunctions applies a series of template functions to a value
func applyTemplateFunctions(value string, functions []string) string {
	if len(functions) == 0 {
		return value
	}
	
	result := value
	for _, fn := range functions {
		switch fn {
		case "title":
			if len(result) > 0 {
				var builder strings.Builder
				builder.Grow(len(result))
				builder.WriteString(strings.ToUpper(result[:1]))
				builder.WriteString(result[1:])
				result = builder.String()
			}
		case "upper":
			result = strings.ToUpper(result)
		case "lower":
			result = strings.ToLower(result)
		}
	}
	return result
}

// Template function metadata
var templateFunctions = {{if .TemplateFunctions}}map[string]map[string]map[string][]string{
{{- range $msgID, $localeMap := .TemplateFunctions}}
	"{{$msgID}}": {
		{{- range $locale, $fieldMap := $localeMap}}
		"{{$locale}}": {
			{{- range $field, $functions := $fieldMap}}
			"{{$field}}": {{"{"}}{{range $functions}}"{{.}}",{{end}}{{"}"}},
			{{- end}}
		},
		{{- end}}
	},
{{- end}}
}{{else}}map[string]map[string]map[string][]string(nil){{end}}

// Localizable interface for all i18n types
type Localizable interface {
	Localize(locale string) string
	ID() string
}

{{range .PlaceholderDefs}}
{{- if .IsValue}}
type {{.StructName}} struct {
	Value string
}

// New{{.StructName}} creates a new {{.StructName}} instance
func New{{.StructName}}(value string) {{.StructName}} {
	return {{.StructName}}{Value: value}
}

func (p {{.StructName}}) Localize(locale string) string {
	return p.Value
}

func (p {{.StructName}}) ID() string {
	return "{{(index .Items 0).ID}}"
}
{{- else}}
type {{.StructName}} struct {
	id string
}

// New{{.StructName}} creates a new {{.StructName}} instance
func New{{.StructName}}(id string) {{.StructName}} {
	return {{.StructName}}{id: id}
}

func (p {{.StructName}}) Localize(locale string) string {
	// Use embedded placeholder data for localization
	if templates, exists := placeholderData[p.id]; exists {
		if localized, exists := templates[locale]; exists {
			return localized
		}
		// Fallback to any available locale
		for _, text := range templates {
			return text
		}
	}
	// Final fallback to ID
	return p.id
}

func (p {{.StructName}}) ID() string {
	return p.id
}
{{- end}}

{{- if not .IsValue}}
// {{.StructName}}s provides utility access to {{.StructName}} instances.
//
// This utility struct contains pre-defined instances for common use cases.
// Each field provides access to localized text values.
//
// Available instances:
{{- range .Items}}
//   - {{.FieldName}}: "{{.ID}}"
{{- end}}
var {{.StructName}}s = struct {
{{- $structName := .StructName}}
{{- range $item := .Items}}
	// {{$item.FieldName}} represents "{{$item.ID}}"
	//
	// Localized values:
	{{- range $locale, $value := $item.Templates}}
	//   • [{{$locale}}] "{{$value}}"
	{{- end}}
	{{$item.FieldName}} {{$structName}}
{{- end}}
}{
{{- range .Items}}
	{{.FieldName}}: {{$structName}}{id: "{{.ID}}"},
{{- end}}
}
{{- end}}
{{end}}

{{range $msg := .MessageDefs}}
type {{$msg.StructName}} struct {
{{- range $msg.Fields}}
	{{.FieldName}} {{.Type}}
{{- end}}
{{- if .SupportsCount}}
	count *int
{{- end}}
}

// New{{$msg.StructName}} creates a new {{$msg.StructName}} instance.
//
// Available localized templates:
{{- $locales := sortLocales $msg.Templates}}
{{- range $locale := $locales}}
{{- if $msg.RawTemplates}}
//   • [{{$locale}}] {{formatPluralTemplate (index $msg.RawTemplates $locale)}}
{{- else}}
//   • [{{$locale}}] {{formatPluralTemplate (index $msg.Templates $locale)}}
{{- end}}
{{- end}}
{{- if .SupportsCount}}
//
// This message supports pluralization using WithPluralCount() method.
// Plural forms are handled automatically based on CLDR rules.
{{- end}}
func New{{$msg.StructName}}({{- range $i, $field := $msg.Fields}}{{if $i}}, {{end}}{{safeIdent (camelCase .TemplateKey)}} {{.Type}}{{- end}}) {{$msg.StructName}} {
	return {{$msg.StructName}}{
{{- range $msg.Fields}}
		{{.FieldName}}: {{safeIdent (camelCase .TemplateKey)}},
{{- end}}
	}
}

{{- if .SupportsCount}}
// WithPluralCount adds count support for pluralization.
//
// This method enables automatic plural form selection based on CLDR rules.
// The count value is used to determine the appropriate plural form (one, other, etc.)
// for languages that support pluralization.
//
// Example usage:
//   msg := New{{$msg.StructName}}(...).WithPluralCount(5)
//   localized := msg.Localize("en") // Uses "other" form for count > 1
func (m {{$msg.StructName}}) WithPluralCount(count int) {{$msg.StructName}} {
	m.count = &count
	return m
}
{{- end}}

func (m {{$msg.StructName}}) Localize(locale string) string {
	templateData := buildTemplateData("{{$msg.ID}}", locale, map[string]string{
{{- range $msg.Fields}}
		"{{.TemplateKey}}": m.{{.FieldName}}.Localize(locale),
{{- end}}
	})
	
	{{- if .SupportsCount}}
	return localizeWithConfig("{{$msg.ID}}", locale, templateData, m.count, "{{.PluralPlaceholder}}")
	{{- else}}
	return localizeWithConfig("{{$msg.ID}}", locale, templateData, nil, "")
	{{- end}}
}

func (m {{$msg.StructName}}) ID() string {
	return "{{$msg.ID}}"
}
{{end}}